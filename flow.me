INFO - в файле, который выдает set_gen_fr_csv_pd_ver3 формат лендмарок такой:
        [[T1нижняя+Т1верхняя], [T2нижняя+Т2верхняя]] в каждой челюсти 16 зубов по 5 лендмарок по 3 точки
        (MDW - 2 точки по 3 значения )
    - Был косяк - расходились лендмарки с мешами т.к. лмки брал из файла где они были в ск челюсти
        Diego_1k.csv
        а надо было из ск головы брать - 
        r"C:\Projects\torchEncoder\csv\diego_landmarks_over_900.csv"

    - При импорте надо инвертировать одну из осей. scale=(.1, .1, -.1), 
        и делать flipped_faces=True, иначе меши зеркально импортируются. Или прозрачными становятся.
        Хак. Автор урсины отмораживается. 

    - при повороте меша зуба на угол он поворачивается куда угодно, но не туда куда надо. - надо эксперимент с 
        кубом в отдельном файле чтоб найти где проблема. 
        - эксперимент с кубом не покатил - проблема в том что надо хитро высчитывать координаты углов куба, эт неохота
            вместо этого нарисовал несколько точек и вращал их как одно целое ( с использованием точки-предка )
            интересные дела - ф-ция cv2.estimateAffine3D не покатила для них - флаг успешности трансформации выдавался 0.
            хотя 2 набора точек скачанных из примера в инете афинно перестраивались друг в дружку. причина неизвестна, 
            Нашел просто питонскую ф-цию для ригид трансформа и она заработала. 
            на произвольном найденном в сети наборе точек для которой сработала cv2.estimateAffine3D эта ф-ция показала 
            такие-же результаты. 
        !!!! - что выяснилось после эксперимента в файле tooth_mesh.py: 
                - все scale надо делать для конкретной точки, или меша, не для базого объекта, от которого наследуешься. 
                - world_rotation или не world на результат по крайней мере с точками не влияет
                - z вращение должно быть с отрицательным знаком. 
        - вместо масштабирования лендмарок просто поделил их массивы на 10. Это привело к тому что зубы перестали улетать в 
            бесконечность, но все равно неправильно крутятся и движутся. 
        - следующая идея - проверять соответствие лендмарок зубам. 
            - убрал все скейлы, убрал деление лендмарок и отодвинул камеру и свет назад - чем проще, тем лучше. 
                вид тот-же т.е. трансформ линеен, что и было ожидаемо. 
            - а проблема, видимо в том, что позиция лендмарки зуба никак не привязана к его ToothID.
                - надо проверять, а пока добился чтобы один зуб 37й и только его лендмарки были. 
                    и все работает если убрать scale по оси z == -1. все черное (свет) и зеркальное, но трансформ считает правильно. 
                    возможно сначала надо считать трансформ, потом все скейлить и рисовать. 
                        - так не выйдет, проблема в отображении а не в неправильном пересчете. 
                        - еще стрем в том что в зубах у меня flipped_faces задается в базовом энтити а в лендмарках в потомках.
                - DONE сеть обучается на данных, которые никак не привязаны к tooth_id. 
                    при формировании датасета, если зубов меньше чем 16 в конец т1 и т2 дописываются нули.  
                    надо сделать набитие лендмарок по такому-же принципу. 
        - начался новый год. - проблема с лендмарками в том, что у матриц поворота у которых на главной диагонали не единицы, 
            они криво позиционируются. надо масштабировать?
        
        - normsR = np.linalg.norm(rotM, axis=1) норма ввращения - если одно число 0 или , то не влияет - нормы получаются единичные. 
            если axis не указывать - норма получается 1,7 значения матрицы уполовиниваются
            но вращение визуально не отличается от случая если матрицу не нормировать. 
        - сдедующая идея - упражняться с движением зубов. 
            для этого делаем функционал - выбираем зуб и двигаем крутим. 
        - DONE!!!!!следующая идея - чтобы поправить косяки вращения зубов - сдвинуть координаты лендмарок
             на первую лендмарку T1
            и потом считать трансформ, затем то же с зубом - сдвиг, трансформ, обратный сдвиг. 
            взять за вектор перемещение в центр можно первую лендмарку, можно 3-ю - это граница жинживы, 
            она примерно в геометрическом центре зуба. 
            особенность в том, что вращать необходимо обязательно родителя зуба, 
            иначе вращается вокрг старого глобального центра. 
            новая мысоль пришла - а ведь если переместить только лендмарки и 
            в новой ск посчитать вращение и перемещение - его потом можно использовать 
            и в глобальной ск. так что передаем только лендмарки. 
            передача одной только лендмарки приводит к единичной матрице поворота. 
            странное дело. перетаскивание лендмарок в начало координат никак 
            не меняет матрицу поворота. а только меняет вектор перемещения. 
            отсюда новая идея - выключить движ повернуть меш зуба матрицей,
            а подвинуть вручную. посмотреть насколько одним движением получится 
            вписать меш в лендмарки. 
            А у меня в приложении - один родитель для всех зубов челюсти. 
            но это в принципе можно переделать
            итог - неправильно считались углы Эйлера. сделал через scypi 
            сначала выяснил что матрица трансформации была правильная. - 
            умножил ее на первую лендмарку зуба из набора t1, сдвинул на 
            матрицу трансляции и получил те же значения из набора T2.
            далее понял что проблема в углах эйлера. и переделал.
        
    - начал анимировать стейджи, тупо поделив все ротейшены и трансляции на 
        шаги. Получается фигня - если транслейшн по количеству перемещеия 
        больше чем поворот, зуб едет сначала вбок, потом к месту назначения. 
        т.е. не по оптимальной (кратчайшей траектории), мог бы догадаться 
        что так будет. 
        Сперва планировал положение стейджей наэмулировать, чтобы понять 
        учится сетка или нет. в принципе чтобы понять, и такое положение дел 
        устроит. Такой движ конечно не для показа, и датасет формировать будем 
        из кода. В принципе, ничего криминального. просто реальный датасет потом
        надо будет брать из анатомии, и тут вопрос - стоит-ли сейчас на это тратить
        время?????
        аргументы:
            за - все будет довольно быстро и можно оценить архитектуру сетки. 
            против - по сути  будет бесполезная работа,в прод не пойдет.
        можно еще соптимизировать алгоритм и тогда уже и показ можно сделать. 
            - это уже интересно. как сделать оптимальный движ????
            -  а в общем то и особо оптимизировать ничего не надо. По крайней 
                мере пока. может пока глянуть как остальные зубы двигаться будут? ок, начали
    
    - следующая большая задача выбрать и обучить архиектуру для стейджинга. 
        есть сомнения что энкодер с параллельным вычислением всех стейджей - хорошая затея, 
        т.к. каждый следующий стейдж будучи скорректированным не приведет к коррекции всех 
        последовательных и ошибки будут накапливаться. попутная мысль: может корректировать 
        одновременно все стейджи, но на это нужно ресурсов пропорционально количеству стейджей. 
        поэтому все-таки наврное lstm. Но, непонятно как учить lstm. Что для него есть
        набор обучающей выборки, а что - метки. далее надо думать откуда эти метки брать. 



TODO - DONE в ursina meshes сделать лендмарки из файла, 
    - DONE сделать ригид трансформ мешей как в проекте . (ох задачка)
        - трансформ посчитал для каждого зуба, теперь его надо к мешу применить. Как?
            - DONE трансформ надо считать для каждого зуба. надо побить лендмарки по зубам.(хихи)
            - вроде как меш уже есть и нарисован, но не понятно, как c ним быть, т.к. он внутри Entity
                и как вариант есть numpy-stl можно попробовать его. https://pypi.org/project/numpy-stl/
        - трансформ как вариант есть такой: https://stackoverflow.com/questions/21206870/opencv-rigid-transformation-between-two-3d-point-clouds
            его надо разбирать
            
    - отобразить виды челюстей перпендикулярно на плоскость окклюзии. Через меню. 

    - отобразить lm в виде мешей. с
        - DONE со сферами не понятно как размер менять, - 
            а вот как - менять надо в генераторе. тогда будет меняться каждая Entity
            если в предке, то меняется у всех в итераторе. 
    - Анимировать переходы t1-t2 

